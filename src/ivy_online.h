static struct section { const char *name; const char *text; } sections[]=
{
  { "introduction",
    "\n"
    "Ivy is an extensible, dynamically typed, late binding language intended to\n"
    "be used as an embedded command language.  It can also be used stand-alone:\n"
    "it can execute script files from the command line or presents a\n"
    "read-eval-print loop (REPL) to the user if no files are given.\n"
    "\n"
    "Ivy's extensibility is based on the fact that statements are syntactically\n"
    "identical to function calls.  Also blocks (surrounded by braces) may be used\n"
    "as function arguments.  Thus, new user-defined statements can be added just\n"
    "by defining functions.  Function arguments are packaged up as thunks and may\n"
    "have their evaluation delayed and execution environment modified.  This\n"
    "allows user defined functions to do many of the things that traditional\n"
    "language statements can do.\n"
    "\n"
    "A number of features make Ivy suitable as a command language.  Commands in\n"
    "Ivy are just function calls, but with a convenient lightweight syntax. \n"
    "Also, Ivy supports named arguments, default argument values and variadic\n"
    "functions.\n"
    "\n"
    "Ivy source code is compiled to byte-code which is then interpreted.  Ivy's\n"
    "compiler and interpreter are both event driven (meaning that they return to\n"
    "the top level when more input is needed).  This allows Ivy to be easily\n"
    "embedded into other programs.\n"
    "\n"
    "Ivy uses garbage collection for memory management.\n"
    "\n"
  },
  { "invocation",
    "\n"
    "       ivy [-u] [-t] [-c] [filenames...]\n"
    "\n"
    "              If no filenames are given, ivy takes input from the keyboard\n"
    "\n"
    "              -t  is a debugging aid which displays the parse tree as\n"
    "                  commands are entered\n"
    "\n"
    "              -u  is a debugging aid which unassembles the byte-code as\n"
    "                  it's made\n"
    "\n"
    "              -c  calculator mode.  prints the result of each command/\n"
    "                  expression which is immediately executed\n"
    "\n"
    "\n"
    "For example, here is \"hello world\" in Ivy interactive mode:\n"
    "\n"
    "       ivy\n"
    "       ->print \"Hello, world\"\n"
    "       Hello, world\n"
    "       ->\n"
    "\n"
    "When calculator mode is used (-c option), the value of each command is\n"
    "printed:\n"
    "\n"
    "       ivy -c\n"
    "       ->10;20\n"
    "       10\n"
    "       20\n"
    "       ->\n"
    "\n"
  },
  { "syntax",
    "\n"
    "### Comments\n"
    "\n"
    "Ivy uses *#* to introduce comments.  Everything from an unquoted *#* to the\n"
    "end of the line is a comment.  *#* was chosen so that the very first line in\n"
    "an Ivy program can be *#!/usr/bin/ivy*, which makes the file into a script\n"
    "in UNIX.\n"
    "\n"
    "### Commands\n"
    "\n"
    "There is a command format for function calls, where one or more commands\n"
    "are provided on a single logical line:\n"
    "\n"
    "       command arg arg arg ; command arg arg arg ; ...\n"
    "\n"
    "Newlines are permitted within parenthesis, brackets and braces and in this\n"
    "way commands may span multiple physical lines.\n"
    "\n"
    "The value of a list of commands is the value returned by the last command.\n"
    "\n"
    "Arguments may be separated with whitespace or commas.  Arguments are\n"
    "expressions.\n"
    "\n"
    "Commands are simple names or several names separated with periods (for\n"
    "member selection).  If anything other than this is provided, the command and\n"
    "its arguments are treated as a list of expressions and they are sequentially\n"
    "evaluated (and the final value is the value of the last expression).\n"
    "\n"
    "       expression expression expression ; command arg arg arg ; ...\n"
    "\n"
    "Sometimes you may want to suppress the treatment of a simple name as a\n"
    "command (for example, to return a function).  To do this, enclose it within\n"
    "parenthesis:\n"
    "\n"
    "       (name)\n"
    "\n"
    "Note that if you try to call a non-function value with zero arguments, the\n"
    "result is the value itself.  This is relevant when you use Ivy\n"
    "interactively (when invoked with the -c option):\n"
    "\n"
    "       ->a=10\n"
    "       10\n"
    "       ->a\n"
    "       10\n"
    "\n"
    "*a* alone on a line is treated as a command, and is called with zero\n"
    "arguments, and returns itself.\n"
    "\n"
    "### Blocks\n"
    "\n"
    "Commands may appear at the top-level (non-enclosed) and within braces to\n"
    "make a block.\n"
    "\n"
    "       { commands }\n"
    "\n"
    "The entire block is treated as a single expression and may be used as an\n"
    "argument for a command.\n"
    "\n"
    "Block structured statements such as *if* are just function calls but with\n"
    "blocks given as arguments.  The traditional *if...else if...else* statement\n"
    "looks like this in Ivy:\n"
    "\n"
    "       if a==1 {\n"
    "              print \"A is 1\"\n"
    "       } a==2 {\n"
    "              print \"A is 2\"\n"
    "       } a==3 {\n"
    "              print \"A is 3\"\n"
    "       } {\n"
    "              print \"A is something else\"\n"
    "       }\n"
    "\n"
    "It is equivalent to calling *if* as a function like this:\n"
    "\n"
    "       if(a==1, print(\"A is 1\"), a==2, print(\"A is 2\"), a==3, print(\"A is\n"
    "       3\"), print(\"A is something else\"))\n"
    "\n"
    "### Lists\n"
    "\n"
    "A list of expressions is expected within parenthesis and brackets:\n"
    "\n"
    "       (list)               Argument list, parenthetical expression,\n"
    "                            or formal args for function definition.\n"
    "\n"
    "       [list]               An object.\n"
    "\n"
    "A list is expected for function arguments and objects.  A list may also be\n"
    "provided for simple parenthetical expressions.  In this case, the\n"
    "expressions of the list are evaluated in turn from left to right, and the\n"
    "last one provides the value of the parenthetical expression.\n"
    "\n"
    "       func(2 3)             Call func with two args: 2 and 3\n"
    "\n"
    "       3*(2 3)              Results in the value 9\n"
    "\n"
    "Expressions within a list can be separated with whitespace, commas or\n"
    "semicolons.  These are all identical in this context:\n"
    "\n"
    "       func(10 20 40)        Call func with three args\n"
    "       func(10,20;40)        Call func with three args\n"
    "       func(10;,20,,,40)      Call func with three args\n"
    "\n"
    "Note that successive separators with nothing between them are ignored:\n"
    "\n"
    "       func(1,2) is exactly the same as func(1,,,,2)\n"
    "\n"
    "Note however, that an empty set of parenthesis has meaning:\n"
    "\n"
    "       func(() 20)    Call func with two args: void and 20.\n"
    "\n"
    "Since whitespace may be used to separate expressions, ambiguities between\n"
    "symbols which can be both infix and prefix operators result.  These\n"
    "ambiguities are resolved by noting the typographical distance between the\n"
    "symbol and its potential arguments.  The rule is that if the distance is\n"
    "balanced, the operator is infix, otherwise it's prefix:\n"
    "\n"
    "       a - b                One expression: subtract b from a\n"
    "       a  -b                Two expressions: a and negated b\n"
    "       f (7)                Two expressions: f and 7.\n"
    "       f(7)                 One expression: a call to f with arg 7\n"
    "       f ( 7 )              One expression: a call to f with arg 7\n"
    "       f  ( 7 )              Two expressions: f and 7.\n"
    "\n"
    "Note that tabs occur every 8 spaces for this purpose.\n"
    "\n"
  },
  { "variables",
    "\n"
    "### Scoping rules\n"
    "\n"
    "Variables set (assigned to) outside of functions are global variables.  They\n"
    "will be visible in any function or scope.\n"
    "\n"
    "If a variable is assigned to inside of a function and there is no global\n"
    "variable of the same name, a local variable will be created within the\n"
    "function.\n"
    "\n"
    "The *var* statement can be used to force the creation of local variables,\n"
    "even if there are global variables with the same name.\n"
    "\n"
    "Functions have their own scope.  Local variables created within a function\n"
    "are only visible within the function.  Nested functions can see their\n"
    "parent's variables.  \n"
    "\n"
    "Statements and blocks do not have their own scope.  The only exception is\n"
    "the *scope* statement.  Local variables created in its body will be visible\n"
    "only within its body.\n"
    "\n"
    "### Assignment\n"
    "\n"
    "Ivy supports nested multi-assignment via objects:\n"
    "\n"
    "       [a,b,[x,y]] = [1,2,[9,10]]\n"
    "\n"
    "Functions may return an object for multi-assignment:\n"
    "\n"
    "       fn multi() [1 2 3]\n"
    "\n"
    "       [a,b,c]=multi()\n"
    "\n"
    "Ivy is unlike most languages in that it does not know that a variable will\n"
    "be used as an L-value until very late (not until the assignment takes\n"
    "place).  Therefore more things are legal L-values than you would expect. \n"
    "For example, if a function returns a variable, it may be assigned to:\n"
    "\n"
    "       ->x=1\n"
    "       ->fn rtnvar() x\n"
    "       ->print x\n"
    "       1\n"
    "       ->rtnvar()=10\n"
    "       ->print x\n"
    "       10\n"
    "\n"
    "This works for multi-assignment also:\n"
    "\n"
    "       # Select a set of variables to assign to\n"
    "       fn rtn(n) {\n"
    "              if n==1 {\n"
    "                     return [x,y,z]\n"
    "              } {\n"
    "                     return [i,j,k]\n"
    "       }\n"
    "       # Make sure they exist\n"
    "       x=y=z=0\n"
    "       i=j=l=0\n"
    "       # Assign\n"
    "       rtn(1)=[1,2,3]\n"
    "       # x, y and z have been assigned to.\n"
    "\n"
    "Note that the variables must already exist for this to work, otherwise they\n"
    "will be created as local variables within the function.  They will still be\n"
    "assigned to, but it is probably not what you want.\n"
    "\n"
  },
  { "values",
    "\n"
    "### Objects\n"
    "\n"
    "Objects are catch-all data structures which may be indexed by number, symbol\n"
    "or string.  Objects indexed by number are similar to arrays.  Objects\n"
    "indexed by symbol are similar to structures.  Objects indexed by string are\n"
    "similar to hash tables.\n"
    "\n"
    "A mixture of index types may be used on the same object, but always\n"
    "refer to different locations (symbol foo and string \"foo\" can have different\n"
    "values).\n"
    "\n"
    "An automatic array is used for numbered indexing.  This array expands to\n"
    "accommodate whatever index is used.  If you store a value at index 0 and\n"
    "also at index 999, then space for 1000 values will be allocated.\n"
    "\n"
    "When arrays are created all at once, the first item will be at index 0:\n"
    "\n"
    "       ->o=[10 20 30]\n"
    "       ->print o[0]\n"
    "       10\n"
    "       ->print o[1]\n"
    "       20\n"
    "       ->print o[2]\n"
    "       30\n"
    "       ->\n"
    "\n"
    "Auto-expanding hash tables are used for symbol and string indexing.  These\n"
    "hash tables expand to twice their size when they reach half full.  Symbol\n"
    "indexing is faster than string indexing since, for symbols, the hash value\n"
    "is just the address of the symbol.\n"
    "\n"
    "Objects can be created either member by member:\n"
    "\n"
    "       o=[]\n"
    "       o.a=5\n"
    "       o.b=6\n"
    "       o(1)=7\n"
    "       o(\"foo\")=8\n"
    "\n"
    "or all at once:\n"
    "\n"
    "       o=[`a=5, `b=6, `1=7, `\"foo\"=8]\n"
    "\n"
    "Objects are assigned by reference.  This means that if you have an\n"
    "object in one variable:\n"
    "\n"
    "       x=[1 2 3]\n"
    "\n"
    "And you assign it to another:\n"
    "\n"
    "       y=x\n"
    "\n"
    "And then change one of the members of x:\n"
    "\n"
    "       x(0)=5\n"
    "\n"
    "Then the change will appear both in x and in y.\n"
    "\n"
    "### void\n"
    "\n"
    "The special value *void* is returned when you attempt to look up an object\n"
    "member, but it's missing.  *void* is equivalent to false or 0 when used with\n"
    "*if*.\n"
    "\n"
    "Here is an example:\n"
    "\n"
    "       ->a=[]\n"
    "       ->if a.b print(\"it exists\")\n"
    "       ->a.b=1\n"
    "       ->if a.b print(\"it exists\")\n"
    "       it exists\n"
    "       ->\n"
    "\n"
    "### this\n"
    "\n"
    "*this* is a read-only symbol that returns the current activation record.  An\n"
    "activation record is an Ivy object which is used to hold local variables.\n"
    "\n"
    "       ->a=10\n"
    "       ->b=20\n"
    "       ->print this\n"
    "       [ 1 at 0x0x1390498\n"
    "              `a=10\n"
    "              `mom=[ 0 at 0x0x13904e0 (globals) ]\n"
    "              `b=20\n"
    "       ]\n"
    "       ->print this.a\n"
    "       10\n"
    "       ->\n"
    "\n"
    "### mom\n"
    "\n"
    "*mom* is an object member present in objects used as activation records.  It\n"
    "refers to the object used as the next outer scope.  *mom* can be used to\n"
    "access variables in the next outer scope:\n"
    "\n"
    "       ->x=10\n"
    "       ->fn foo() {\n"
    "       ->     var x = 20\n"
    "       ->     print x\n"
    "       ->     print mom.x\n"
    "       ->}\n"
    "       ->foo\n"
    "       20\n"
    "       10\n"
    "       ->\n"
    "\n"
    "### Closures\n"
    "\n"
    "When functions are treated as data, they are always passed around as\n"
    "closures.  A closure has the address of the code for the function and a\n"
    "reference to its environment- the object which was the activation record at\n"
    "the time when the function was defined.  This object will become the next\n"
    "outer scope of the function (it's activation record's mom) when the function\n"
    "is called.\n"
    "\n"
    "The environment part of a closure value can be replaced in various ways. \n"
    "There is an operator to do this directly:\n"
    "\n"
    "       modified = original::new_environment\n"
    "\n"
    "When a closure is retrieved from an object with a member called mom via dot\n"
    "notation, the object will replace the environment part of the closure:\n"
    "\n"
    "       ->x=10\n"
    "       ->fn p() print(x)\n"
    "       ->a=[`mom=this, `x=20, `p=p]\n"
    "       ->p()\n"
    "       10\n"
    "       ->a.p()\n"
    "       20\n"
    "\n"
    "### Symbols\n"
    "\n"
    "There are symbols:\n"
    "\n"
    "       `hello\n"
    "\n"
    "Symbols can be tested for equality:\n"
    "\n"
    "       `hello==`hello        # True\n"
    "       `hello==`goodbye       # False\n"
    "\n"
    "There is an interned string table for all symbols, so within Ivy, the check\n"
    "for symbol equality is fast: symbols are identical if their addresses match.\n"
    "\n"
    "Symbols can be used as object indices.  Variables within a scope are\n"
    "indexed by symbols.  These are equivalent:\n"
    "\n"
    "       a(`hello)=5\n"
    "       a.hello=5\n"
    "\n"
    "### Integers\n"
    "\n"
    "Integers may be entered in a variety of bases:\n"
    "\n"
    "       x=0o127       # Octal\n"
    "       x=0x80        # Hexadecimal\n"
    "       x=0b11        # Binary\n"
    "       x=123         # Decimal\n"
    "\n"
    "Octal, binary and hexadecimal digits may be interspersed with\n"
    "underscores (_) for enhanced readability:\n"
    "\n"
    "       x=0xADDED_FEE\n"
    "\n"
    "Also the ASCII value of a character may be taken as an integer:\n"
    "\n"
    "       x='A'         # The value 65\n"
    "\n"
    "The following \"escape sequences\" may also be used in place of a\n"
    "character:\n"
    "\n"
    "       x='\\n'        # New-line\n"
    "       x='\\r'        # Return\n"
    "       x='\\b'        # Backspace\n"
    "       x='\\t'        # Tab\n"
    "       x='\\a'        # Alert (bell)\n"
    "       x='\\e'        # Escape\n"
    "       x='\\f'        # Form-feed\n"
    "       x='\\^A'       # Ctrl-A (works for ^@ to ^_ and ^?)\n"
    "       x='\\010'       # Octal for 8\n"
    "       x='\\xFF'       # Hexadecimal for 255\n"
    "       x='\\\\'        # \\\n"
    "       x='\\q'        # q (undefined characters return themselves)\n"
    "\n"
    "### Floating point numbers\n"
    "\n"
    "       x=.125\n"
    "       x=.125e3\n"
    "       x=0.3\n"
    "\n"
    "### Strings\n"
    "\n"
    "String constants are enclosed in double-quotes:\n"
    "\n"
    "       x=\"Hello there\"\n"
    "\n"
    "Escape sequences may also be used inside of strings.\n"
    "\n"
  },
  { "expressions",
    "\n"
    "An expression is a single or dual operand operator with arguments, a\n"
    "constant, a variable, a function definition, a block enclosed within braces,\n"
    "a function call, an object or parenthetical expression.  Examples of each of\n"
    "these cases follow:\n"
    "\n"
    "       ~expr                Single operand\n"
    "\n"
    "       expr+expr             Dual operand\n"
    "\n"
    "       25                   Constant\n"
    "\n"
    "       (expressions)         Precedence\n"
    "       {commands}\n"
    "\n"
    "       expr(expr ...)        Function call\n"
    "\n"
    "       [1 2 3 4]             An array object\n"
    "\n"
    "       [`next=item `value=1]  A structure object\n"
    "\n"
    "       (fn (x,y) x*y)(3,5)    Calling an anonymous function\n"
    "\n"
    "\n"
  },
  { "operators",
    "\n"
    "Here are the operators grouped from highest precedence to lowest:\n"
    "\n"
    "       `                           # Named argument\n"
    "\n"
    "       .                           # Member selection\n"
    "\n"
    "       ::                          # Modify environment part of closure\n"
    "\n"
    "       ( )                         # Function call\n"
    "\n"
    "       & - ~ ! ++ -- *              # Single operand\n"
    "\n"
    "       << >>                       # Shift group\n"
    "\n"
    "       * / & %                     # Multiply group\n"
    "\n"
    "       + - | ^                     # Add group\n"
    "\n"
    "       == > < >= <= !=              # Comparison group\n"
    "\n"
    "       &&                          # Logical and\n"
    "\n"
    "       ||                          # Logical or\n"
    "\n"
    "       = <<= >>= *= /= %= += -= |= ^= .=      # Pre-assignments\n"
    "       : <<: >>: *: /: %: +: -: |: ^: .:      # Post-assignments\n"
    "\n"
    "       \\                           # Sequential evaluation: returns\n"
    "                                   # result of right side.\n"
    "\n"
    "       ,                           # Expression separation\n"
    "\n"
    "       ;                           # Command separation\n"
    "\n"
    "A detailed description of each operator follows:\n"
    "\n"
    "### ` Symbol quoting\n"
    "\n"
    "This operator can be used to prevent a symbol from being\n"
    "replaced by its value.  Instead the symbol is used directly as the value. \n"
    "It is also used to explicitly state the argument or member name in a\n"
    "command, function call or object.  For example:\n"
    "\n"
    "       open `name=\"joe.c\",  `mode=\"r\"\n"
    "       square(`x=5, `y=6)\n"
    "       [`1=5 `0=7]                  # Array object\n"
    "       [`x=10 `y=10]                # Structure object\n"
    "\n"
    "### . Member selection\n"
    "\n"
    "This operator is used to select a named member from an\n"
    "object.  For example:\n"
    "\n"
    "       o=[`x=5, `y=10]       # Create an object\n"
    "       pr o.x               # Print member x\n"
    "       pr o.y               # Print member y\n"
    "       pr o(\"y\")             # Same as above\n"
    "\n"
    "### :: Modify environment\n"
    "\n"
    "This operator replaces the environment part of the closure\n"
    "on the left side with the object on the right side.\n"
    "\n"
    "       x = 2\n"
    "       fn foo(n) { print x * n }\n"
    "\n"
    "       # Call foo in its recorded environment-\n"
    "       # in this case, the global variables\n"
    "\n"
    "       foo(7)               # Prints 14\n"
    "\n"
    "       my_obj=[`mom=this, `x=3]\n"
    "\n"
    "       # Call foo with my_obj as its environment\n"
    "\n"
    "       foo::my_obj(7)        # Prints 21\n"
    "\n"
    "### ( ) Function call\n"
    "\n"
    "This operator calls the function resulting from the\n"
    "expression on the left with the arguments inside of the parenthesis.  This\n"
    "operator can also be used for object member selection and for string\n"
    "character selection and substring operations.  Examples of each of these\n"
    "follow:\n"
    "\n"
    "       x.y(5)               # Call function y in object x\n"
    "\n"
    "       z(0)=1, z(1)=2        # Set numbered members of an object\n"
    "\n"
    "       z(\"foo\")=3, z(\"bar\")=4 # Set string members of an object\n"
    "\n"
    "       z(`foo)=3, z(`bar)=4   # Set symbol members of an object\n"
    "\n"
    "       pr \"Hello\"(0)         # Prints 72\n"
    "\n"
    "       pr \"Hello\"(1,3)       # Prints \"el\" (selects substring\n"
    "                            # beginning with first index and\n"
    "                            # end before second).\n"
    "\n"
    "\n"
    "### - Negate\n"
    "\n"
    "### & Address of.\n"
    "\n"
    "This operator converts its operand into a thunk (a zero\n"
    "argument nameless function thunk with no environment).  The thunk can\n"
    "be called with () or *.\n"
    "\n"
    "### ~ Bit-wise one's complement\n"
    "\n"
    "### ! Logical not\n"
    "\n"
    "### ++ Pre or post increment\n"
    "\n"
    "Pre or post increment depending on whether it precedes or follows\n"
    "a variable\n"
    "\n"
    "### -- Pre or post decrement\n"
    "\n"
    "### * Indirection\n"
    "\n"
    "This prefix operator is used to call a zero argument\n"
    "function or thunk.\n"
    "\n"
    "       fn set(&a b) {\n"
    "              *a=b\n"
    "       }\n"
    "\n"
    "       x=3\n"
    "       set x 10       # Set x to 10\n"
    "       print x       # Prints 10\n"
    "\n"
    "### << Bit-wise shift left\n"
    "\n"
    "### >> Bit-wise shift right\n"
    "\n"
    "### * Multiply\n"
    "\n"
    "### / Divide\n"
    "\n"
    "### & Bit-wise AND\n"
    "\n"
    "### % Modulus (Remainder)\n"
    "\n"
    "### + Add or concatenate\n"
    "\n"
    "In addition to adding integers, this operator concatenates\n"
    "strings if strings are passed to it.  For example:\n"
    "\n"
    "       print \"Hello\"+\" There\" # Prints \"Hello There\"\n"
    "\n"
    "\"+\" will also append an element on the right into an\n"
    "array object on the left:\n"
    "\n"
    "       a=[1 2 3]\n"
    "       a+=4                 # a now is [ 1 2 3 4 ]\n"
    "\n"
    "       print []+1+2+3+4       # same as print [1 2 3 4]\n"
    "       print []+1+2+3+[4 5]   # same as print [1 2 3 [4 5]]\n"
    "\n"
    "### - Subtract\n"
    "\n"
    "### | Bit-wise or\n"
    "\n"
    "If objects are given as arguments to OR, OR unions the\n"
    "objects together into a single object.  If the objects have\n"
    "numerically referenced members, OR will append the array on the\n"
    "right to the array on the left.  For example:\n"
    "\n"
    "       a=[1 2 3]\n"
    "       b=[4 5 6]\n"
    "       a|=b                 # a now is [1 2 3 4 5 6]\n"
    "\n"
    "### ^ Bit-wise Exclusive OR\n"
    "\n"
    "### == Equal\n"
    "\n"
    "Returns 1 (true) if arguments are equal or 0 (false) if arguments are not\n"
    "equal.  Can be used for strings, numbers, symbols and objects.  For objects,\n"
    "\"==\" tests if the two arguments are the same object, not if the two\n"
    "arguments have equivalent objects.\n"
    "\n"
    "### > Greater than\n"
    "\n"
    "### >= Greater than or equal to\n"
    "\n"
    "### <  Less than\n"
    "\n"
    "### <= Less than or equal to\n"
    "\n"
    "### != Not equal to\n"
    "\n"
    "### && Logical and\n"
    "\n"
    "The right argument is only evaluated if the left argument is\n"
    "true (non-zero).\n"
    "\n"
    "### || Logical or\n"
    "\n"
    "The right argument is evaluated only if the left argument is\n"
    "false (zero).\n"
    "\n"
    "### = Pre-assignment\n"
    "\n"
    "The right side is evaluated and the result is stored in the variable\n"
    "specified on the left side.  The right side's result is also returned.\n"
    "\n"
    "### : Post-assignment\n"
    "\n"
    "The right side is evaluated and the result is stored in the\n"
    "variable specified on the left side.  The left side's original value\n"
    "is returned.\n"
    "\n"
    "### X= Pre-assignment group\n"
    "\n"
    "These translate directly into: \"left = left X right\"\n"
    "\n"
    "### X: Post-assignment group\n"
    "\n"
    "These translate directly into: \"left : left X right\"\n"
    "\n"
    "Notes on assignment groups:\n"
    "\n"
    "       .=     translates into \"left = left . right\" and is\n"
    "              useful for traversing linked lists.  For example:\n"
    "\n"
    "              for list=void\\ x=0, x!=10, ++x {       # Build list\n"
    "                list=[`next=list, `value=x]\n"
    "              }\n"
    "\n"
    "              (note, this builds the list in reverse\n"
    "              order.  9,8,7...)\n"
    "                            \n"
    "              for a=list, a, a.=next {       # Print list  (second\n"
    "                                          # expr evals for 0)\n"
    "                     print a.value\n"
    "              }\n"
    "\n"
    "       x+:1   Is the same as x++\n"
    "       x+=1   Is the same as ++x\n"
    "\n"
    "\n"
    "\":\" is useful for shifting the value of variables around.  In this example,\n"
    "a gets b, b gets c, and c gets 5:\n"
    "\n"
    "       a:b:c:5\n"
    "\n"
    "\":\" is also useful for swapping the values of variables.  In this example, a\n"
    "gets swapped with b:\n"
    "\n"
    "       a:b:a\n"
    "\n"
    "### \\ Sequential evaluation\n"
    "\n"
    "The left and then the right argument are evaluated and the\n"
    "result of the right argument is returned.\n"
    "\n"
    "### , Argument separator\n"
    "\n"
    "When this is used in statements which require only a single\n"
    "expression, it has the same effect as \\\n"
    "\n"
    "\n"
  },
  { "functions",
    "\n"
    "### Function declaration syntax:\n"
    "\n"
    "Command format named function declarations:\n"
    "\n"
    "       fn name(args) expr\n"
    "\n"
    "       fn name(args) {\n"
    "              body\n"
    "       }\n"
    "\n"
    "Expression format named function declarations:\n"
    "\n"
    "       fn(name, (args), body-expr)\n"
    "\n"
    "Command format anonymous function:\n"
    "\n"
    "       { fn (args) body-expr }\n"
    "\n"
    "Expression format anonymous function:\n"
    "\n"
    "       fn((args), body-expr)\n"
    "\n"
    "These are all equivalent:\n"
    "\n"
    "       fn square(x) x*x\n"
    "\n"
    "       fn square (x) {\n"
    "              x*x\n"
    "       }\n"
    "\n"
    "       square = { fn (x) x*x }\n"
    "\n"
    "       square = fn((x), x*x)\n"
    "\n"
    "The last forms define so-called \"Lambda\" (anonymous) functions.  You\n"
    "can call anonymous functions without assigning them:\n"
    "\n"
    "       x=fn((x),x*x)(6)       # x gets assigned 36\n"
    "\n"
    "You can also define named functions right in the middle of an expression,\n"
    "and immediately call them:\n"
    "\n"
    "       y=fn(square,(x),x*x)(5)# y gets assigned 25\n"
    "       print square(6)       # Prints 36\n"
    "\n"
    "### Argument lists\n"
    "\n"
    "You may specify zero or more formal arguments.  Each argument must be\n"
    "provided during a function call, or an error occurs.\n"
    "\n"
    "       fn mm(x,y) x*y\n"
    "\n"
    "       mm(1)      --> \"Error: Missing arguments\"\n"
    "\n"
    "       mm(1,2,3)  --> \"Error: Too many arguments\"\n"
    "\n"
    "       mm(3,4)    --> returns 12.\n"
    "\n"
    "However, default values may be specified.  If an argument with a\n"
    "default value is missing, no error occurs and the default value is used\n"
    "instead:\n"
    "\n"
    "       fn mm(x=5,y=6) x*y\n"
    "\n"
    "       mm()       --> x=5,y=6 --> 30\n"
    "\n"
    "       mm(6)      --> x=6,y=6 --> 36\n"
    "\n"
    "       mm(6,2)    --> x=6,y=2 --> 12\n"
    "\n"
    "Expressions may be used for the default values.  The expressions are\n"
    "evaluated when the function is called (not when defined).  The evaluation\n"
    "happens in the body of the function (where the expression may declare local\n"
    "variables).  The order is left to right, and expressions on the right may\n"
    "use arguments to their left.\n"
    "\n"
    "       fn zz(x=5,y={ var q=5; x }) x*y+q\n"
    "\n"
    "       q=10\n"
    "\n"
    "       zz()      --> x=5,q=5,y=5  --> 25\n"
    "\n"
    "       zz(3)     --> x=3,q=5,y=3  --> 14\n"
    "\n"
    "       zz(3, 3)  --> x=3,q=10,y=3 --> 19\n"
    "\n"
    "Arguments may be passed by name.  When an argument is passed by name, a\n"
    "local variable of that name is injected into the function's body.  Variables\n"
    "may be created which are not in the formal argument list.  Named and\n"
    "unnamed arguments may be mixed in the same function call.  The named\n"
    "arguments have no effect on how the unnamed arguments are processed: the\n"
    "unnamed arguments are matched up left-to-right with the formal argument list\n"
    "as if there were no provided named arguments.  This means that an unnamed\n"
    "argument may overwrite a named argument if it occurs after the named\n"
    "argument, or vice-versa.  If there were fewer unnamed arguments than in the\n"
    "formal argument list, and the missing ones were declared with default\n"
    "values, and they were not provided with a named argument, then the default\n"
    "value is used.  If arguments without default values are missing, and they\n"
    "were not provided by a named argument, an error occurs.\n"
    "\n"
    "       fn zz(x,y,z=10) x+y+z+e\n"
    "\n"
    "       zz(`e=1,`y=2,3) --> x=3, y=2, z=10, e=1 --> 16\n"
    "\n"
    "Extra unnamed arguments may be collected into an object with your choice of\n"
    "name with the following syntax:\n"
    "\n"
    "       fn zz(x,extras...) {\n"
    "              print \"x = \", x\n"
    "              forindex z extras {\n"
    "                     print \"extras(\", z, \") = \", extras(z)\n"
    "              }\n"
    "       }\n"
    "\n"
    "       zz(5,6,7,8) --> prints\n"
    "\n"
    "       x = 5\n"
    "       extras(0) = 6\n"
    "       extras(1) = 7\n"
    "       extras(2) = 8\n"
    "\n"
    "### Function execution\n"
    "\n"
    "When the body of a function gets control, its activation record (the\n"
    "object used for the function's local variables) gets several variables:\n"
    "\n"
    "\n"
    "\n"
    "       this   The function's activation record itself as an object\n"
    "\n"
    "              print this     Prints all local variables\n"
    "\n"
    "*this* is not a variable, it's a special symbol that is replaced by the\n"
    "activation record object.\n"
    "\n"
    "       mom    The next outer lexical scope.\n"
    "\n"
    "Mom is a normal variable.  If you assign it, the next outer lexical scope is\n"
    "changed to the specified object.\n"
    "\n"
    "Functions may be assigned to variables and passed to other functions.  For\n"
    "example you can define a function *apply* which applies a function to an\n"
    "argument:\n"
    "\n"
    "       fn apply(x y) {\n"
    "              return x(y)\n"
    "       }\n"
    "\n"
    "       fn square(x) {\n"
    "              return x*x\n"
    "       }\n"
    "\n"
    "       print apply(square,5)  # Prints 25\n"
    "\n"
    "\n"
    "Functions can return other named or unnamed functions.  (Remember to enclose\n"
    "the function name in parenthesis to suppress command interpretation, or use\n"
    "return).  For example:\n"
    "\n"
    "       fn square(x) {\n"
    "              return x*x\n"
    "       }\n"
    "\n"
    "       fn foo() {\n"
    "              return square\n"
    "       }\n"
    "\n"
    "       print foo()(4)        # Prints 16\n"
    "\n"
    "       fn bar() {\n"
    "              (fn((x),x*x))  # Return lambda function\n"
    "       }\n"
    "\n"
    "       print bar()(4)        # Prints 16\n"
    "\n"
    "Functions can be declared inside of other functions.  This is\n"
    "especially useful for manipulating the argument lists of pre-existing\n"
    "functions.  Suppose you had an averaging function:\n"
    "\n"
    "       fn avg(func from to) {\n"
    "              var x, accu = 0\n"
    "              for x = from, x != to, ++x {\n"
    "                     accu += func(x)\n"
    "              }\n"
    "              return accu / (to - from)\n"
    "       }\n"
    "\n"
    "And suppose that you have another function which takes two arguments which\n"
    "you'd like its average, but with one argument set to a constant:\n"
    "\n"
    "       fn add(a b) {\n"
    "              return a+b\n"
    "       }\n"
    "\n"
    "You could do this by using a function which creates a function\n"
    "which calls add, but with one argument set to a constant:\n"
    "\n"
    "       fn curry(y) {\n"
    "              return fn((x), add(x,y))\n"
    "       }\n"
    "\n"
    "       Now 'avg' can be used on 'add':\n"
    "\n"
    "       print avg(curry(20),0,10) # Prints 24\n"
    "\n"
    "### Delayed evaluation of arguments\n"
    "\n"
    "Arguments may be prefixed with ampersands to prevent them from being\n"
    "immediately evaluated.  The marked argument is packaged up as a \"thunk\"- a\n"
    "zero argument function with the environment set as the calling function's\n"
    "activation record.  The function may call the thunk whenever it wants,\n"
    "either by using the normal function call syntax or by using the indirection\n"
    "operator, '*'.\n"
    "\n"
    "For example, here is a function which sets a specified variable to\n"
    "a value:\n"
    "\n"
    "       fn set(&x,y) { *x = y }\n"
    "\n"
    "       set q 10\n"
    "\n"
    "       print q--> prints 10\n"
    "\n"
  },
  { "statements",
    "\n"
    "### If statement\n"
    "\n"
    "       if test-expr-1 {\n"
    "              expr-1\n"
    "       } test-expr-2 {\n"
    "              expr-2\n"
    "       } test-expr-3 {\n"
    "              expr-3\n"
    "       } {\n"
    "              otherwise-expr\n"
    "       }\n"
    "\n"
    "       if(test-expr-1,expr-1,test-expr-2,expr-2,...,otherwise-expr)\n"
    "\n"
    "### Foreach statement\n"
    "\n"
    "       foreach name expr block\n"
    "\n"
    "       foreach `label name expr block\n"
    "\n"
    "Sets the variable *name* to each element in the object resulting from *expr*\n"
    "and executes the *block*.\n"
    "\n"
    "*foreach* may optionally be labeled for matching with the argument to\n"
    "*break* and *continue*\n"
    "\n"
    "       ->foreach a [1 2 3] print(a)\n"
    "       1\n"
    "       2\n"
    "       3\n"
    "       ->\n"
    "\n"
    "### Forindex statement\n"
    "\n"
    "       forindex name expr block\n"
    "\n"
    "       forindex `label name expr block\n"
    "\n"
    "Sets the variable *name* to each valid index into the object resulting from\n"
    "*expr* and executes the block.\n"
    "\n"
    "*forindex* may optionally be labeled for matching with the argument to\n"
    "*break* and *continue*\n"
    "\n"
    "       ->forindex a [10 20 30] print(a)\n"
    "       0\n"
    "       1\n"
    "       2\n"
    "       ->\n"
    "\n"
    "### Loop statement\n"
    "\n"
    "       loop block\n"
    "       loop `label block\n"
    "\n"
    "The block gets repeatedly executed until a 'break' or 'until' statement\n"
    "within the block terminates the loop.\n"
    "\n"
    "*loop* may optionally be labeled for matching with the argument to *break*\n"
    "and *continue*.\n"
    "\n"
    "### While statement\n"
    "\n"
    "       while expr block\n"
    "\n"
    "       while `label expr block\n"
    "\n"
    "The block is repeatedly executed if the expression is true.\n"
    "\n"
    "*while* may optionally be labeled for matching with the argument to *break*\n"
    "and *continue*.\n"
    "\n"
    "### For statement\n"
    "\n"
    "       for init, test, incr block\n"
    "\n"
    "       for `label init, test, incr block\n"
    "\n"
    "This is a shorthand for the following while statement:\n"
    "\n"
    "       init\n"
    "       while test {\n"
    "              block\n"
    "              incr\n"
    "       }\n"
    "\n"
    "Thus,\n"
    "\n"
    "*init* is usually used as an index variable initializer\n"
    "\n"
    "*test* is the loop test\n"
    "\n"
    "*incr* is the index variable incrementer\n"
    "\n"
    "*for* may optionally be labeled for matching with the argument to *break*\n"
    "and *continue*\n"
    "\n"
    "### Return statement\n"
    "\n"
    "       return\n"
    "\n"
    "       return expr\n"
    "\n"
    "*return* exits the function it is executed in with the given return value or\n"
    "with *void* if no value is given.\n"
    "\n"
    "### Break statement\n"
    "\n"
    "       break\n"
    "\n"
    "       break LABEL\n"
    "\n"
    "*break* jumps out of the innermost or labeled loop\n"
    "\n"
    "### Continue statement\n"
    "\n"
    "       continue\n"
    "\n"
    "       continue LABEL\n"
    "\n"
    "*continue* jumps to the beginning of the innermost or labeled loop.\n"
    "\n"
    "### Until statement\n"
    "\n"
    "       until expr\n"
    "\n"
    "*until* exits the loop it's in if *expr* is true.\n"
    "\n"
    "### Var statement\n"
    "\n"
    "       var a, b, c\n"
    "\n"
    "Declare local variables.  The variables may also have initializers:\n"
    "\n"
    "       var a=10, b=20\n"
    "\n"
    "       fn raise(a) {\n"
    "              var x\n"
    "              for x=1, a, x<<=1\\ --a\n"
    "              return x\n"
    "       }\n"
    "\n"
    "### Scope statement\n"
    "\n"
    "       scope expr expr ...\n"
    "\n"
    "The expressions are evaluated in their own scope.  If they create local\n"
    "variables, they will not show up in the outer scope.  The value of the last\n"
    "expression is returned.\n"
    "\n"
  },
  { "intrinsics",
    "\n"
    "Here are functions that are always built-in.\n"
    "\n"
    "### loadfile\n"
    "\n"
    "       a = loadfile(\"name\")\n"
    "\n"
    "Execute an Ivy source file within an empty global variable scope.  The\n"
    "executed code will only see Ivy's built-in functions.  The final value is\n"
    "returned.\n"
    "\n"
    "### len\n"
    "\n"
    "       len(a)\n"
    "\n"
    "Returns the length of string 'a' or number of elements in\n"
    "array 'a'\n"
    "\n"
    "### print\n"
    "\n"
    "       print(...)\n"
    "\n"
    "Prints the arguments\n"
    "\n"
    "### printf\n"
    "\n"
    "       printf(...)\n"
    "\n"
    "C printf\n"
    "\n"
    "       printf \"%d\\n\", 17\n"
    "\n"
    "### get\n"
    "\n"
    "       a=get()\n"
    "\n"
    "Get a line of input as a string.  Returns void if there is\n"
    "no more input.\n"
    "\n"
    "       # Add line numbers to input\n"
    "       n=1\n"
    "       while a=get() {\n"
    "              print n++, \" \", a\n"
    "       }\n"
    "\n"
    "### atoi\n"
    "\n"
    "       x=atoi(\"2\")\n"
    "\n"
    "Converts a string to a number\n"
    "\n"
    "### itoa\n"
    "\n"
    "       s=itoa(20)\n"
    "\n"
    "Convert a number to a string\n"
    "\n"
    "### clear\n"
    "\n"
    "       clear(...)\n"
    "\n"
    "Frees the values of the listed variables and sets the\n"
    "variables to VOID.\n"
    "\n"
    "### dup\n"
    "\n"
    "       b=dup(a)\n"
    "\n"
    "Make a duplicate of an array/object\n"
    "\n"
    "### match\n"
    "\n"
    "       match(string,pattern,result-variables...)\n"
    "\n"
    "Regular expression pattern matching\n"
    "\n"
    "Return true if string matches pattern (which must be a\n"
    "regular expression string).\n"
    "\n"
    "If there is a match, each spanned area is stored in the\n"
    "corresponding result variable:\n"
    "\n"
    "       match \"fooAbar\" \".*A.*\" a b\n"
    "\n"
    "              a now has \"foo\" and b has \"bar\".\n"
    "\n"
    "It is ok to supply fewer result variables than there are\n"
    "spanning areas.\n"
    "\n"
    "       The regular expression string may be made of:\n"
    "\n"
    "                    .      matches any character.\n"
    "                    *      matches zero or more of the previous character\n"
    "                           (generates a result string).\n"
    "                    +      matches one or more of the previous character\n"
    "                           (generates a result string).\n"
    "                    [...]  matches one character in the list ...\n"
    "                           ranges may be specified with the list, such\n"
    "                           as 0-9, a-z, etc.\n"
    "                    x      other characters match themselves only.\n"
    "\n"
    "Note that the entire string must be spanned for a match to\n"
    "occur:  It is as if the pattern always begins with ^ and\n"
    "ends with $.\n"
    "\n"
  },
  { "math functions",
    "\n"
    "The following functions from the standard C library are provided:\n"
    "\n"
    "       sin() cos() tan() asin() acos() atan() atan2()\n"
    "       sinh() cosh() tanh() asinh() acosh() atanh()\n"
    "       exp() log() log10() pow() hypot() sqrt()\n"
    "       floor() ceil() int() abs() min() max() erf() erfc()\n"
    "       j0() j1() jn() y0() y1() yn()\n"
    "\n"
  },
  { "object-oriented programming",
    "\n"
    "Besides being available for use by the programmer, Ivy's objects are used\n"
    "internally for activation records.  This means that a function's local\n"
    "variables are implemented as object members.\n"
    "\n"
    "The only difference between regular objects and objects used for activation\n"
    "records is the presence of a member called *`mom*.  This member refers to\n"
    "the next outer scoping level.  Ivy uses lexical scoping, so the chain of\n"
    "next outer levels include (for the case of nested functions) the parent\n"
    "function's (*not* the calling function's) activation record, then the global\n"
    "variables (when modules are loaded, they each get their own object for\n"
    "global variables), then finally the object containing Ivy's built-in\n"
    "functions, such as *print*.  During symbol lookup, the chain of moms is\n"
    "searched for the symbol.\n"
    "\n"
    "When functions are passed around, they always come in closures.  A closure\n"
    "contains a pointer to the function's code and a pointer to the environment\n"
    "where it was defined, which is the activation record in effect at that time. \n"
    "The environment is the object that becomes the function's activation\n"
    "record's mom when the function is called.\n"
    "\n"
    "With this understanding, we can proceed towards implementing object-oriented\n"
    "programming in Ivy.  There are two ways to do it: the direct method and the\n"
    "closure method.  They are equivalent, and will be shown side by side.\n"
    "\n"
    "First we need to define a class to hold member functions and static\n"
    "variables (variables shared by all instances of the class).  In the direct\n"
    "method, we just create an object, but with *`mom* set to the current\n"
    "activation record, in this case the one containing the global variables:\n"
    "\n"
    "       My_class=[`mom=this]\n"
    "\n"
    "The special symbol *this* always refers to the object being used as the\n"
    "current activation record.\n"
    "\n"
    "We can add a member function by assigning a lambda (nameless) function to a\n"
    "member name (*show* in this case):\n"
    "\n"
    "       My_class.show = fn((), {\n"
    "              print x\n"
    "       })\n"
    "\n"
    "Or we can do this same thing by using dot notation in the function\n"
    "declaration:\n"
    "\n"
    "       fn My_class.show() {\n"
    "              print x\n"
    "       }\n"
    "       \n"
    "       fn My_class.increment() {\n"
    "              x = x + 1\n"
    "       }\n"
    "\n"
    "Or we could even have included them when we created the object in the first\n"
    "place:\n"
    "\n"
    "       My_class = [\n"
    "              `mom = this\n"
    "       \n"
    "              `show = fn((), {\n"
    "                     print x\n"
    "              })\n"
    "       \n"
    "              `increment = fn((), {\n"
    "                     x = x + 1\n"
    "              })\n"
    "       ]\n"
    "\n"
    "In the closure method, we write a function which returns its activation\n"
    "record.  This will be used as the class.  Any nested functions will become\n"
    "member functions:\n"
    "\n"
    "       fn create_My_class() {\n"
    "       \n"
    "              fn show() {\n"
    "                     print x\n"
    "              }\n"
    "       \n"
    "              return this\n"
    "       }\n"
    "\n"
    "       My_class = create_My_class()\n"
    "\n"
    "The closure method has the advantage of not requiring you to explicitly set\n"
    "*mom*, in case that bothers you.  *My_class.mom* will still exist, however. \n"
    "It was set in the activation record when then function was invoked.\n"
    "\n"
    "We can add more member functions after the class has been created (by either\n"
    "method: assigning lambda functions to member names or by declaring named\n"
    "functions with the dot notation):\n"
    "\n"
    "       fn My_class.increment() {\n"
    "              x = x + 1\n"
    "       }\n"
    "\n"
    "Notice that member functions refer to instance variables as in C++ or Java. \n"
    "There is no need to prefix each instance variable with *self* or *this* as\n"
    "in most languages with prototype based object systems.  On the other hand,\n"
    "calls to sibling member functions should use dot notation:\n"
    "\n"
    "       fn My_class.inc_and_show() {\n"
    "              this.increment()\n"
    "              this.show()\n"
    "       }\n"
    "\n"
    "We need a constructor to create class instances.  This constructor\n"
    "should be a class member.  For the direct method, we write this:\n"
    "\n"
    "       fn My_class.instance(i=[]) {\n"
    "              i.x = 10\n"
    "              i.mom = My_class\n"
    "              return i\n"
    "       }\n"
    "\n"
    "Notice that an empty object is provided as the default value for *i*.  If\n"
    "the *i* argument is missing, this default empty object will become the\n"
    "instance.  If the argument is provided, then the caller provided object is\n"
    "used for the instance.  We will use this capability later for derived\n"
    "classes, where we want to allow the derived class constructor to call the\n"
    "base class constructor.\n"
    "\n"
    "Next, we create an instance variable x and set it to a default value 10.\n"
    "\n"
    "Finally, we set the mom of the instance to the class so that if we call\n"
    "member functions on the instance, the ones defined in the class will be\n"
    "found.\n"
    "\n"
    "For the closure method, the instance creation function is a nested function\n"
    "of *create_My_class* which returns its activation record as the instance. \n"
    "We separate out a construction function from the instance allocator so that\n"
    "it may be later called by derived class constructors:\n"
    "\n"
    "       fn create_My_class() {\n"
    "\n"
    "              fn construct(i) {\n"
    "                     i.x = 10\n"
    "              }\n"
    "\n"
    "              fn instance() {\n"
    "                     construct(this)\n"
    "                     return this\n"
    "              }\n"
    "\n"
    "              fn show() {\n"
    "                     print x\n"
    "              }\n"
    "\n"
    "              fn increment() {\n"
    "                     x = x + 1\n"
    "              }\n"
    "\n"
    "              return this\n"
    "       }\n"
    "\n"
    "Now we create some instances of the class:\n"
    "\n"
    "       instance_1 = My_class.construct()\n"
    "       instance_2 = My_class.construct()\n"
    "\n"
    "The instances are now ready and we can call their member functions:\n"
    "\n"
    "       instance_1.show()   --> prints 10\n"
    "       instance_1.increment()\n"
    "       instance_1.show()   --> prints 11\n"
    "       instance_2.show()   --> prints 10\n"
    "\n"
    "But, the member functions are not in the instance objects, and even then you\n"
    "would expect the called function's activation record's mom to be the class,\n"
    "not the instance.  So what is going on?\n"
    "\n"
    "The member functions are found because we explicitly set *i.mom* to\n"
    "*My_class* in the constructor with the direct method or it was implicitly\n"
    "set this way in the closure method.  In either case, the symbol lookup\n"
    "follows the mom chain as usual.  It finds the closure for *show* or\n"
    "*increment* with the recorded environment being the class object.\n"
    "\n"
    "But the class object is not used for the member function's environment (and\n"
    "here we come to the heart of Ivy's object system).  This is because the . \n"
    "operator replaces the environment part of the closure retrieved from the\n"
    "symbol on its right side (*show* or *increment*) with the object it\n"
    "began the symbol search in on its left side (*instance_1*), but only if\n"
    "that object contains a mom.\n"
    "\n"
    "[If the object did not contain a mom, then the environment replacement does\n"
    "not happen.  Instead the recorded environment is used.  This allows you to\n"
    "use non-class objects as simple containers for other object's member\n"
    "functions:\n"
    "\n"
    "       z=[]\n"
    "       z.show = instance_1.show\n"
    "       z.show()  --> prints 11\n"
    "\n"
    "The environment replacement is happening in the *instance_1.show* part of\n"
    "the assignment above, so *instance_1* is the mom for *show*'s activation\n"
    "record.  Since *z* does not have a mom, *z* is not used as the\n"
    "environment when we finally call show in *z.show()*.]\n"
    "\n"
    "The bottom line is that a function does not know that it is a member\n"
    "function and certainly not which instance to operate on until it has been\n"
    "accessed via the dot notation.  A non-obivious consequence of this is that\n"
    "member functions must use dot notation when calling sibling member\n"
    "functions, even though the dot notation is not required to find them.\n"
    "\n"
    "For example, we could have a function which increments and shows.  We might\n"
    "try writing it like this:\n"
    "\n"
    "       fn My_class.inc_and_show() {\n"
    "              increment()\n"
    "              show()\n"
    "       }\n"
    "\n"
    "But it will not work.  The increment will look up *x* starting in the\n"
    "environment where it was defined.  This is either in the global environment\n"
    "for the direct method or in the class object for the closure method.  Either\n"
    "way, it's not accessing the *x* in the instance.\n"
    "\n"
    "The correct way to write this function is as follows:\n"
    "\n"
    "       fn My_class.inc_and_show() {\n"
    "              mom.increment()\n"
    "              mom.show()\n"
    "       }\n"
    "\n"
    "*Mom* will refer to the instance object when inc_and_show is called.  In\n"
    "this case, you could replace *mom* with *this*.  But it is better to use\n"
    "*mom*, since the member function should not be modifying the activation\n"
    "record of *inc_and_show* itself.\n"
    "\n"
    "### Inheritance\n"
    "\n"
    "We can create a new class based on an existing class like this:\n"
    "\n"
    "       DerivedClass = [ `mom = MyClass ]\n"
    "\n"
    "Since *DerivedClass*'s mom is set to *MyClass*, symbol lookup for member\n"
    "functions will find ones defined in *MyClass* if they are not directly\n"
    "provided in *DerivedClass*.\n"
    "\n"
    "It will need a new instance constructor:\n"
    "\n"
    "       fn DerivedClass.construct(i=[]) {\n"
    "              i = MyClass.construct(i)\n"
    "              i.y = 20\n"
    "              i.mom = DerivedClass\n"
    "              return i\n"
    "       }\n"
    "\n"
    "Notice how we are calling the base class's constructor, but then elaborating\n"
    "the instance by adding a new instance variable *y*.  Naturally the instance's\n"
    "mom is replaced (it had been set to *MyClass* by *MyClass*'s constructor) so\n"
    "that it is set to *DerivedClass*.\n"
    "\n"
    "And we will override one of the member functions:\n"
    "\n"
    "       fn DerivedClass.show() {\n"
    "              print \"Derived\"\n"
    "              print x\n"
    "              print y\n"
    "       }\n"
    "\n"
    "Using the closure method, we provide a new class creation function and then\n"
    "call it:\n"
    "\n"
    "       fn MyClass.create_DerivedClass() {\n"
    "\n"
    "              fn construct(i) {\n"
    "                     mom.mom.construct(i)\n"
    "                     i.y = 20\n"
    "              }\n"
    "\n"
    "              fn show() {\n"
    "                     print \"Derived\"\n"
    "                     print x\n"
    "                     print y\n"
    "              }\n"
    "\n"
    "              return this\n"
    "       }\n"
    "\n"
    "       DerivedClass = MyClass.create_DerivedClass()\n"
    "\n"
    "*create_DerivedClass* is defined as a member of *MyClass* so that when\n"
    "it's called, *create_DerivedClass*'s activation record's mom ends up being\n"
    "*MyClass*.\n"
    "\n"
    "An alternative way of defining *create_DerivedClass* which does not\n"
    "involve modifying *MyClass* at all is as follows:\n"
    "\n"
    "       fn create_DerivedClass() {\n"
    "\n"
    "              mom = MyClass\n"
    "\n"
    "              fn construct(i) {\n"
    "                     mom.mom.construct(i)\n"
    "                     i.y = 20\n"
    "              }\n"
    "\n"
    "              fn show() {\n"
    "                     print \"Derived\"\n"
    "                     print x\n"
    "                     print y\n"
    "              }\n"
    "\n"
    "              return this\n"
    "       }\n"
    "\n"
    "       DerivedClass = create_DerivedClass()\n"
    "\n"
    "Notice that we replaced *create_DerivedClass*'s activation record's mom\n"
    "during execution to connect it with its base class.  Since Ivy is a late\n"
    "binding language, this is perfectly legal to do.\n"
    "\n"
    "In either case, the new construction function adds a new instance variable,\n"
    "*y*, as in the direct method.  It also calls the base class constructor. \n"
    "Notice that we follow mom twice to find it.  Remember that the construction\n"
    "function will have its own activation record when it's called, so one \"mom.\"\n"
    "is needed to traverse to *DerivedClass*.  The second \"mom.\" traversed back\n"
    "to *My_class*, which has the construct function we want to call.\n"
    "\n"
    "Notice that we do not provide a new instance allocation function.  The one\n"
    "in *My_class* does the right thing, so there is no need to replace it.  It\n"
    "will find *DerivedClass*'s *construct* function.\n"
    "\n"
    "Now we can create an instance of the derived class:\n"
    "\n"
    "       derived_instance_1 = DerivedClass.instance()\n"
    "\n"
    "       derived_instance_1.show()  --> Prints:\n"
    "\n"
    "       Derived\n"
    "       10\n"
    "       20\n"
    "\n"
  },
  { 0, 0 }
};
